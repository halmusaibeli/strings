PROGRAM strings
%NOLOCKGROUP

%INCLUDE strings.klh

BEGIN
END strings

-- Public: Takes a string and a separator and splits it into an array
--
-- str : STRING - the STRING to separate
-- sep : STRING - which character separates the string
--
-- Examples:
--
--   split_str('one,two,three',',')
--   # => ['one','two','three','','',...,'']
--
-- Returns an ARRAY[16] of STRING[16]
ROUTINE split_str
  VAR
    i   : INTEGER
    k   : INTEGER
	start    : INTEGER
  BEGIN
    k = 1

    -- initialize the whole out array to ''
    FOR i = 1 TO array_len(out) DO
      out[i] = ''
    ENDFOR

	start = 1

    FOR i = 1 TO (STR_LEN(str)-STR_LEN(sep)) DO
		IF (SUB_STR(str, i, STR_LEN(sep))=sep) THEN
			out[k] = SUB_STR(str, start, (i-start))
			k = k + 1
			start = i+STR_LEN(sep)
		ENDIF
    ENDFOR

	out[k] = SUB_STR(str, start, (STR_LEN(str)-start+1))
  END split_str

-- strip whitespace from left side of string
ROUTINE lstrip
  VAR
    i : INTEGER
  BEGIN
    FOR i = 1 TO STR_LEN(s) DO
      IF SUB_STR(s,i,1) <> ' ' THEN
        RETURN(SUB_STR(s,i,STR_LEN(s)))
      ENDIF
    ENDFOR

    RETURN(s)
  END lstrip

-- strip whitespace from right side of string
ROUTINE rstrip
  VAR
    i : INTEGER
  BEGIN
    FOR i = STR_LEN(s) DOWNTO 1 DO
      IF SUB_STR(s,i,1) <> ' ' THEN
        RETURN(SUB_STR(s,1,i))
      ENDIF
    ENDFOR

    RETURN(s)
  END rstrip

ROUTINE b_to_s
  BEGIN
    IF b THEN
      RETURN('true')
    ELSE
      RETURN('false')
    ENDIF
  END b_to_s

ROUTINE i_to_s
  VAR
    s : STRING[16]
  BEGIN
    IF UNINIT(i) THEN
      RETURN('null')
    ENDIF

    CNV_INT_STR(i, 0, 0, s)
    RETURN(lstrip(s)) 
  END i_to_s

ROUTINE r_to_s
  VAR
    s : STRING[16]
    i : INTEGER
  BEGIN
    IF UNINIT(r) THEN
      RETURN('null')
    ENDIF

    CNV_REAL_STR(r, 0, 3, s)
    s = lstrip(s)

    -- fix -.234 issue
    IF SUB_STR(s,1,1) = '-' THEN
      -- see if next char is .
      IF SUB_STR(s,2,1) = '.' THEN
        s = '-0.' + SUB_STR(s,3,STR_LEN(s))
      ENDIF
    ENDIF

    -- add leading zero
    IF SUB_STR(s,1,1) = '.' THEN
      s = '0' + s
    ENDIF

    -- get rid of trailing zeroes
    FOR i = STR_LEN(s) DOWNTO 1 DO
      IF SUB_STR(s,i,1) <> '0' THEN
        -- see if prev char is a . so we leave 1 trailing zero
        IF SUB_STR(s,i,1) = '.' THEN
          RETURN(SUB_STR(s,1,i+1))
        ELSE
          RETURN(SUB_STR(s,1,i))
        ENDIF
      ENDIF
    ENDFOR

    RETURN(s)
  END r_to_s

ROUTINE p_to_s
  BEGIN
    RETURN('X: ' + r_to_s(p.x) + ' Y: ' + r_to_s(p.y) + ' Z: ' + r_to_s(p.z) + chr(13) &
      + 'W: ' + r_to_s(p.w) + ' P: ' + r_to_s(p.p) + ' R: ' + r_to_s(p.r))
   END p_to_s

-- print xyzwprext data type
ROUTINE pext_to_s
VAR
    configvar : CONFIG
    wrist, elbow, robot : STRING[1]
BEGIN
    IF (UNINIT(uframe_no)) OR (UNINIT(utool_no)) THEN
      WRITE TPERROR('frame number must be set.')
    ENDIF
    configvar = p.config_data
    --joint placement
    -- wrist
    IF (configvar.cfg_flip) THEN
        wrist = 'F'
    ELSE
        wrist = 'N'
    ENDIF
    -- elbow
    IF (configvar.cfg_up) THEN
        elbow = 'U'
    ELSE
        elbow = 'D'
    ENDIF
    -- robot
    IF (configvar.cfg_front) THEN
        robot = 'T'
    ELSE
        robot = 'B'
    ENDIF

    IF (UNINIT(grp_no)) OR (grp_no <= 0) THEN
        RETURN('UF : '+ i_to_s(uframe_no) +', UT : '+ i_to_s(utool_no) +',' & 
            + '  CONFIG : '+ wrist + chr(32) + elbow + chr(32) + robot + ',' &
            + i_to_s((configvar.cfg_turn_no1)) + ',' + i_to_s((configvar.cfg_turn_no2)) &
            + i_to_s((configvar.cfg_turn_no3)) + ', ' + chr(13) &
            + 'X = '+ r_to_s(p.x) +'mm, Y = '+ r_to_s(p.y) + 'mm, Z = '+ r_to_s(p.z) +'mm, '+ chr(13) &
            + 'W = '+ r_to_s(p.w) +'deg, P ='+ r_to_s(p.p) +'deg, R ='+ r_to_s(p.r) +'deg')
    ELSE
        RETURN('GP' + i_to_s(grp_no) + ':' + chr(13) &
            + 'UF : '+ i_to_s(uframe_no) +', UT : '+ i_to_s(utool_no) +',' & 
            + '  CONFIG : '+ wrist + chr(32) + elbow + chr(32) + robot + ',' &
            + i_to_s((configvar.cfg_turn_no1)) + ',' + i_to_s((configvar.cfg_turn_no2)) &
            + i_to_s((configvar.cfg_turn_no3)) + ', ' + chr(13) &
            + 'X = '+ r_to_s(p.x) +'mm, Y = '+ r_to_s(p.y) + 'mm, Z = '+ r_to_s(p.z) +'mm, '+ chr(13) &
            + 'W = '+ r_to_s(p.w) +'deg, P ='+ r_to_s(p.p) +'deg, R ='+ r_to_s(p.r) +'deg')
    ENDIF
END pext_to_s

-- Escapes quotes in a string
ROUTINE esc_quotes
  VAR
    i : INTEGER
    r : STRING[254]
    c : STRING[1]
  BEGIN
    r = ''
    FOR i=1 TO STR_LEN(s) DO
      -- chr(44) is '
      c = SUB_STR(s,i,1)
      IF (c = chr(44)) OR (c = '"') THEN
        r = r + '\'
      ENDIF

      r = r + c
    ENDFOR

    RETURN(r)
  END esc_quotes

-- searches for a string "srchStr" within another 
-- longer string "str"
-- need to handle error catching
-- return a boolean if found of not
ROUTINE search_str
  VAR
  	strLen  : INTEGER
  	srchLen : INTEGER
  	dmmy    : STRING[30]
 	found   : BOOLEAN
  	i       : INTEGER
  BEGIN
  	strLen = STR_LEN(str)
  	srchLen = STR_LEN(srchStr)
  	found = FALSE
  
  	FOR i=1 TO strLen DO
    		dmmy = SUB_STR(str,i,srchLen)
    		IF (dmmy = srchStr) THEN
     		 	found = TRUE
      			GOTO searched
   	 	ENDIF
  	ENDFOR
	SEARCHED::
	
	RETURN(found)
  END search_str

-- Determine if character is a number. A character of 
-- String[1] is evaluated to see if its a number. 
  ROUTINE charisnum
  VAR
    isnum : BOOLEAN
  BEGIN
  	isnum = FALSE
  	IF STR_LEN(s) <= 1 THEN
  		IF (s='0') OR (s='1') OR (s='2') OR  (s='3') OR (s= '4') OR (s='5') OR (s='6') OR (s='7') OR (s='8') OR (s='9') THEN
  			isnum = TRUE
  		ENDIF
  	ELSE
      CLR_IO_STAT(TPDISPLAY)
      WRITE TPERROR(s, ' is not a character')
  	ENDIF
  	RETURN(isnum)
  END charisnum

    -- string to integer
  ROUTINE s_to_i
   VAR
   	int : INTEGER
   	i : INTEGER
   	isNum : BOOLEAN
  BEGIN
  	isNum = FALSE
  	-- evaluate if string is a number
  	IF SUB_STR(s,1,1) = '-' THEN
  		int = -1
  		 IF charisnum(SUB_STR(s,2,1)) THEN
  		 	isNum = TRUE
  		 ENDIF
  	ELSE
  		IF charisnum(SUB_STR(s,1,1)) THEN
  			isNum = TRUE
  		ENDIF
  	ENDIF
  	--If not a number abort
  	IF isNum = FALSE THEN
      WRITE TPERROR(s, ' is not a number')
  	ENDIF
  	
  	CNV_STR_INT(s, int)
  	
  	IF UNINIT(int) THEN
      WRITE TPERROR(s, ' is not a integer')
  	ENDIF
  	
  	RETURN(int)
  	
  END s_to_i  
